package com.demo.review;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * @author ：wxw
 * @description：XXXX
 * @date ：2020-06-23 11:09
 */
public class MapDetail {
    public void getHashMapDetail(){
        Map<String,String> map =new HashMap<>();
        /**
         * 引入地址：https://github.com/553899811/NewBie-Plan/blob/master/docs/notes/Java%E5%9F%BA%E7%A1%80/Java-%E5%AE%B9%E5%99%A8/Map/HashMap.mdhttps://github.com/553899811/NewBie-Plan/blob/master/docs/notes/Java%E5%9F%BA%E7%A1%80/Java-%E5%AE%B9%E5%99%A8/Map/HashMap.md
         * 继承抽象类 abstractMap
         * 哈希表：
         * 哈希表的主干就是数组；
         * 要新增或者查找元素，根据当前元素的关键字 通过某个函数映射到数组的某一个位置，通过数组下标一次定位就可以完成操作。
         * 存储位置 = f（关键字）   f()称为【哈希函数】
         * 存储和查找【通过哈希计算出实际存储位置，然后在数组中对应位置取出】
         *
         * 哈希冲突问题：
         * 不同元素通过哈希函数得到相同的实际存储地址。----》哈希碰撞 和 哈希冲突
         * 解决方法：
         * 开放寻址法（发生冲突，继续寻找下一块未被占用的存储地址）
         * 再散列函数发
         * 链地址法（hasnmap采用这种方法）
         *
         * hashmap由 数组+链表组成 数组是Hashmap的主体，链表是为了解决哈希冲突存在
         * hashmap的数组位置不含链表，那么对于查找，添加等操作很快，仅需一次寻址即可，如果含有列表，添加的话为O(0),查询话需要遍历链表，通过key对象的equals方法逐一对比。
         * 成员
         * table  我们称为 桶(数组)，初始化为16  transient Node<K,V>[] table
         * Node   final hash 当前节点Hash值  key 当前节点的Key  value当前节点value  next当前节点的下一指向
         *     static class Node<K,V> implements Map.Entry<K,V> {
         *         final int hash;
         *         final K key;
         *         V value;
         *         Node<K,V> next;
         *     }
         * 初始化hashmap数组的长度  static final int Defalut_inital_capacity =1<<4
         * 最大数组的长度   static finnal int Maximum_capacity = 1<<30
         * 默认负载因子  default_load_factor =0.75f  抛出异常 concurrentModificationException
         * transient int midCount 实际存储Key-value 键值对的个数   transient int size ；
         * static final int treeify_thershold = 8   长度达到8就会将 列表转化为红黑色
         * 当某一个桶位置上到链表长度为6 由红黑树 转换为链表
         * int threshold
         *
         * 变量名	                变量初始值	变量值含义
         * DEFAULT_INITIAL_CAPACITY	2^4	        HashMap默认初始化桶(数组)数量
         * MAXIMUM_CAPACITY	        2^30	    HashMap最大桶(数组)数量
         * DEFAULT_LOAD_FACTOR	    0.75	    负载因子(影响扩容机制)
         * size	                    无初始化值	实际存储的key-value键值对的个数
         * TREEIFY_THRESHOLD	    8	        链表长度>8时变化数据结构为红黑树
         * UNTREEIFY_THRESHOLD	    6	        当桶位置上元素个数
         *
         * 构造函数
         * 虽然自定义 InitialCapacity 但是并不是 任意数组长度 而是经过tableSizeFor方法，得到一个个大于输入参数并且最近2的整次幂的数。比如10 得到16
         * 常规构造器，并没有为 table分配内存空间（有一个入参为指定map的构造器除外） 只有Put时候才真正构建table 数组
         *
         * 基本操作：
         * 1、如果获取Hash值
         * --扰动函数
         * 获取 hashcode的值
         * 获取 key的hash值
         *   上述代码中key.hashCode()函数调用的是超类Object类中的哈希函数,JVM进而调用本地方法,返回一个int值;
         *   理论上是一个int类型的值,范围为-2147483648-2147483647,
         *   前后加起来大概有40亿的映射空间,的确这么大的空间,映射会很均匀
         *   但是这么大的数组,内存中是放不下的。HashMap的初始化数组只有16
         *   ,所以这个散列值是无法直接拿来用的,所以要对hashCode做一些处理
         *   扰动函数的结果: key的hash是hashCode中高位和低位的复合产物;
         * 2、获取桶索引位置
         * 【1】为什么要做&运算呢?
         *    答: 与操作的结果就是高位全部归零,只保留低位值,用来做数组下标访问。
         *    举一个例子说明,初始化长度为16,16-1=15 .
         *    2进制(4字节,32位)表示就是 00000000 00000000 00000000 00001111
         *    和 某散列值做与操作结果就是
         *    00000000 10100101 11000100 00100101
         *    00000000 00000000 00000000 00001111
         *  & -------------------------------------
         *    00000000 00000000 00000000 00000101 //高位全部归零,只保留尾部四位
         *
         *   【2】为什么是 n-1 呢?
         *    答: 源头就是HashMap的数组长度为什么要取2的整数幂?
         *    因为这样(n-1)
         *    相当于一个"低位掩码";
         *    这样能结合下面的&运算使散列更为均匀,减少冲突
         *    (相对其他数字来说,比如10的话,下面我们以00100101和00110001这两个数做一个例子说明)
         *     和15&      和10&       和15&    和10&
         *    00100101  00100101    00110001  00110001
         *    00001111  00001010    00001111  00001010
         *    &-------  --------    --------  --------
         *    00000101  00000000    00000001  00000000
         *
         *    我们发现两个不同的数00100101 和0011001 分别和15以及10做与运算,
         *    和15做&运算会得到两个不同的结果(即会被散列到不同的桶位置上),而和10做与运算得到的是相同的结果(散列到同一个位置上),
         *    这就会出现冲突!!!!!
         *
         *   【3】hash&(len-1) 和 hash%len 的效果是相同的;
         *    例如 x=1<<4,即2^4=16;
         *    x:   00010000
         *    x-1: 00001111
         *    我们假设一个数M=01011011 (十进制为:Integer.valueOf("01011011",2) = 91)
         *    M :  01011011
         *    x-1: 00001111
         *    &-------------
         *         00001011(十进制数为:11)
         *    91 % 16 = 11
         *    证明两者效果相同,位运算的性能更高在操作系统级别来分析;
         *   【4】为什么扰动函数是那样子的呢?
         *    如下图所示,h>>>16 之后和h 做异或运算得到的hash前半部分是h的高8位,
         *    后半部分是hash的高16位和低16位的复合产物;
         * 3、put方法
         *   首先判断table是否为空或者null,如果是则 初始化数组table
         *   根据键值Key计算hash值 并得到桶索引位置（(n-1)&hash) 如果table[i]=null,直接新建节点添加，转向第6步，如果table不为空，则转向3步
         *   判断table的首个元素是否和key相同，相同的话直接覆盖value，否则转向4步，这里相同指的是hashcode和equals
         *   判断table[i]是否为treeNode，即table[i]是否为红黑树，如果是红黑树则直接在树中插入键值对，否则转到第5步
         *   遍历table[i] 判断 链表长度 是否大于8，大于8 将链表转成红黑数，在红黑树中执行插入操作，否则进行链表的插入操作。遍历过程中如果发现Key则直接覆盖value
         *   插入成功，判断实际存在的键值是否超过了最大容量（阈值），如果超过，则进行扩容
         * 在JDK1.6中index = hash % len 做与运算 ,在JDK 1.7/1.8中 变为了 i =(len-1) & hash,两者的作用是相同的;
         * Put时如果key为null，存储位置为table[0]或table[0]的冲突链上(table为HashMap中存的数组),如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value，如果对应数据不存在,则添加到链表的头上(保证插入O(1));
         * 简介：首先判断Keys是否是Null,如果是Null 则直接调用 PutforNullKey方法。若不为空，则计算hash值，根据hash值搜索在table索引位置，如果有
         * 元素则循环遍历链表，比较是否存在相同的key,若存在则覆盖key value。否则将该元素 保存在链头。若table在该处没有元素，则直接保存
         *
         * --拉链法
         *    HashMap<String, String> map = new HashMap<>();
         *     map.put("K1","V1");
         *     map.put("K2","V2");
         *     map.put("K3","V3");
         *
         *     [1]新建一个HashMap,默认大小为1<<4(16);
         *     [2]插入Node<K1,V1> ,先计算K1的hash值为115,使用和(len-1)做&运算得到所在的桶下标为115&15=3;
         *     [3]插入Node<K2,V2>,先计算K2的hash值为118,使用和(len-1)做&运算得到所在的桶下标为118&15=6;
         *     [4]插入Node<K3,V3>,先计算K3的hash值为118,使用和(len-1)做&运算得到所在的桶下标为118&15=6,插在<K2,V2>后面.
         *
         * 4、get方法
         *  根据key计算hash值 桶位置index=hash&(len-1)
         *  如果key 就是上述数组index,直接返回该元素的值  如果该数组index位置为treeNode类型，则查询红黑树 否则按照链表遍历查询
         *
         *
         *  高级特性：
         * 1、扩容机制
         * resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍,并进行数据迁移。
         * 扩容之后的元素，要么在原来位置上，要么在原来位置上 移动2^n的位置上、
         * hashmap的原来桶数量为16,即n-1=15(二进制表示:1111)
         * [1]扩容前
         * n-1 :  0000 0000 0000 0000 0000 0000 0000 1111
         * hash1: 1111 1111 1111 1111 0000 1111 0000 0101
         *     &----------------------------------------
         *       0000 0000 0000 0000 0000 0000 0000 0101 (桶位置为5)
         *
         *
         * n-1 :  0000 0000 0000 0000 0000 0000 0000 1111
         * hash2: 1111 1111 1111 1111 0000 1111 0001 0101
         *     &----------------------------------------
         *       0000 0000 0000 0000 0000 0000 0000 0101 (桶位置也是5)
         * 两个hash值不同的对象,和n-1做&运算之后,得到相同的结果;
         * [2]扩容后
         * hashmap此时桶的数量变为32,即n-1=31(二进制表示:11111)
         * n-1:   0000 0000 0000 0000 0000 0000 0001 1111
         * hash1: 1111 1111 1111 1111 0000 1111 0000 0101
         *      &---------------------------------------
         *       0000 0000 0000 0000 0000 0000 0000 0101 (扩容后,桶位置依旧是5)
         *
         * n-1:   0000 0000 0000 0000 0000 0000 0001 1111
         * hash2: 1111 1111 1111 1111 0000 1111 0001 0101
         *      &---------------------------------------
         *       0000 0000 0000 0000 0000 0000 0001 0101 (扩容后,桶位置变为之前5+2^4=21)
         *   元素在hashmap扩容之后,会重新计算桶下标,从上面的例子中可以看出来,hash1的桶位置在扩容前后没有发生变化,
         *   hash2的桶位置在扩容前后发生了变化;
         *
         * 上述扩容过程中&运算的关键点就在于
         * 扩容之后新的长度(n-1)转化为2进制之后新增的bit为1,
         * 而key的hash 值所对应位置的bit是1 还是0,
         * 如果是0的话那么桶位置就不会变化,依旧为index;
         * 是1 的话桶位置就会变成index+oldCap;
         * 通过if((e.hash&oldCap)==0)来判断hash的新增判断bit是1还是0;
         * 为什么2倍扩展，原因是2进制数字
         *
         * 2、负载因子--》0.75原因 【时间和空间的一个折中办法】
         *  理想状态下,在随机哈希值的情况，对于loadfactor = 0.75 ,
         *   虽然由于粒度调整会产生较大的方差,桶中的Node的分布频率服从参数为0.5的泊松分布;
         *    而对于一个bucket是空或非空的概率为0.5，通过牛顿二项式等数学计算，得到这个loadfactor的值为log（2），约等于0.693.
         *   同回答者所说，可能小于0.75 大于等于log（2）的factor都能提供更好的性能，0.75这个数说不定是 pulled out of a hat
         *
         * 3、线程安全问题
         * 表现：jdk1.7 并发死环，丢数据   jdk1.8 并发丢数据
         * 扩容顺序： 1.7 头插法：新增节点插入链表头部  1.8 尾插法
         * jdk 1.7 扩容的问题
         * 之前我们分析了transfer 方法就是让 原链表顺序发生逆转。
         * 现在假设有2个线程A,B
         * A在扩容获取到元素3时，执行完 Entry<K,V> next = e.next，之后发生了时间片切换，此时next 指向 元素 7 .
         * B上场开始扩容，B扩容完毕之后，元素7 的next指针指向 元素3 ，而CPU切回到线程A之后，对于A继续执行，但是此时 ，元素3和元素7 之间互相指向。如图所示，
         * A线程就一直会陷在do while循环中找 e.next!=null之中。
         * jdk 1.8 扩容问题
         * 假设线程A在704行判断 oldTab[j]!=null,然后在705行 将其oldTab[j]设置为null,此时时间片切换，
         * 线程B在704行判断oldTab[j]为空，直接跳过这个索引下的旧数据，然后往下走执行完整个扩容过程，
         * 会直接导致这个桶位置上的所有元素丢失。
         *
         * 4、选择红黑树的原因
         *
         * 二叉搜索树（BST: BinarySearch Tree） ->  平衡二叉树（AVL Tree）->  红黑树（2-3树）
         */
    }

    public void getLinkHashMap(){
        LinkedHashMap<String,String> map =new LinkedHashMap<>();
        /**
         *  linkHashMap问题
         *  主要就是调用HashMap构造函数初始化了一个Entry[] table，然后调用自身的init初始化了一个只有头结点的双向链表。
         *  保证有序，双向链表
         */

    }

    public void getCurrentHashMap(){
        
    }
}
